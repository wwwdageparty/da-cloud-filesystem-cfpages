interface Env {
  DB: D1Database;
  DA_WRITE_TOKEN: string;
}

// 1. Define the Protocol Types
interface FileSystemPayload {
  id?: number;
  parentId?: number;
  name?: string;
  content?: string;
  isFolder?: boolean;
}

interface RequestBody {
  version: string;
  service: string;
  action: "init" | "list" | "read" | "write" | "delete";
  request_id: string;
  payload: FileSystemPayload;
}

// --- Action Functions ---

async function handleInit(env: Env) {
  // We use your fixed schema as requested, ignoring c1Unique
  const tableSql = `
    CREATE TABLE IF NOT EXISTS ${C_TableName} (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      c1 VARCHAR(255), 
      c2 VARCHAR(255), c3 VARCHAR(255),
      i1 INT, i2 INT, i3 INT,
      d1 DOUBLE, d2 DOUBLE, d3 DOUBLE,
      t1 TEXT, t2 TEXT, t3 TEXT,
      v1 TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
      v2 TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
      v3 TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    );
  `;

  // Define indices for the filesystem performance
  const indices = [
    `CREATE INDEX IF NOT EXISTS idx_${C_TableName}_c1 ON ${C_TableName}(c1)`,
    `CREATE INDEX IF NOT EXISTS idx_${C_TableName}_i1 ON ${C_TableName}(i1)`,
    `CREATE INDEX IF NOT EXISTS idx_${C_TableName}_i2 ON ${C_TableName}(i2)`,
    `CREATE INDEX IF NOT EXISTS idx_${C_TableName}_v1 ON ${C_TableName}(v1)`,
    `CREATE INDEX IF NOT EXISTS idx_${C_TableName}_v2 ON ${C_TableName}(v2)`
  ];

  // Batch execute for efficiency
  const statements = [
    env.DB.prepare(tableSql),
    ...indices.map(sql => env.DB.prepare(sql))
  ];

  await env.DB.batch(statements);
  
  return { message: `Table ${C_TableName} and indices initialized successfully.` };
}

async function handleList(payload: FileSystemPayload, env: Env) {
  const { results } = await env.DB.prepare(
    `SELECT id, c1 as name, i2 as isFolder, v2 as modified 
     FROM ${C_TableName} 
     WHERE i1 = ? 
     ORDER BY i2 DESC, c1 ASC`
  )
  .bind(payload.parentId ?? 0)
  .all();
  return { items: results };
}

async function handleRead(payload: FileSystemPayload, env: Env) {
  const file = await env.DB.prepare(
    `SELECT c1 as name, t1 as content 
     FROM ${C_TableName} 
     WHERE id = ? AND i2 = 0`
  )
  .bind(payload.id)
  .first<{ name: string; content: string }>();

  if (!file) throw new Error("File not found");
  return file;
}

async function handleWrite(payload: FileSystemPayload, env: Env) {
  const { id, parentId, name, content, isFolder } = payload;

  if (id) {
    // Update existing file content
    await env.DB.prepare(
      `UPDATE ${C_TableName} SET t1 = ?, v2 = CURRENT_TIMESTAMP WHERE id = ?`
    )
    .bind(content, id)
    .run();
    return { success: true, id };
  } else {
    // Create new (i2: 1 for folder, 0 for file)
    const type = isFolder ? 1 : 0;
    const info = await env.DB.prepare(
      `INSERT INTO ${C_TableName} (c1, i1, i2, t1) VALUES (?, ?, ?, ?)`
    )
    .bind(name, parentId ?? 0, type, content ?? null)
    .run();
    return { success: true, id: info.meta.last_row_id };
  }
}

async function handleDelete(payload: FileSystemPayload, env: Env) {
  if (!payload.id) throw new Error("Missing ID for delete action");

  // This SQL finds the target ID AND all its descendants recursively
  const recursiveDeleteSql = `
    DELETE FROM ${C_TableName}
    WHERE id IN (
      WITH RECURSIVE subordinates AS (
        SELECT id FROM ${C_TableName} WHERE id = ?
        UNION ALL
        SELECT t.id FROM ${C_TableName} t
        INNER JOIN subordinates s ON t.i1 = s.id
      )
      SELECT id FROM subordinates
    );
  `;

  const result = await env.DB.prepare(recursiveDeleteSql)
    .bind(payload.id)
    .run();

  if (result.meta.changes === 0) {
    throw new Error("Item not found or already deleted");
  }

  return { 
    success: true, 
    id: payload.id, 
    rowsDeleted: result.meta.changes 
  };
}

// --- Main Router ---

export const onRequestPost: PagesFunction<Env> = async (context) => {
  const { request, env } = context;

  const validToken = env.DA_WRITE_TOKEN;
  const authHeader = request.headers.get("Authorization");

  // Check if token exists in Env and matches the header
  if (!validToken || authHeader !== `Bearer ${validToken}`) {
    return new Response(JSON.stringify({ error: "Unauthorized" }), { status: 401 });
  }
  
  try {
    const body = await request.json<RequestBody>();
    
    if (body.service !== "filesystem") {
      throw new Error("Invalid service");
    }

    let result;

    switch (body.action) {
      case "init":
        result = await handleInit(env);
        break;
      case "list":
        result = await handleList(body.payload, env);
        break;
      case "read":
        result = await handleRead(body.payload, env);
        break;
      case "write":
        result = await handleWrite(body.payload, env);
        break;
      case "delete":
        result = await handleDelete(body.payload, env);
        break;
      default:
        throw new Error(`Action ${body.action} not recognized`);
    }

    return Response.json({
      version: "v1",
      service: "filesystem",
      action: body.action,
      request_id: body.request_id,
      payload: result
    });

  } catch (err: any) {
    return Response.json({ 
      error: err.message, 
      request_id: "error" 
    }, { status: 500 });
  }
};


const C_TableName = "da_filesystem_root";
const C_SERVICE = "da-cloud-filesystem-cfp";
const C_VERSION = "0.0.1";
let G_INSTANCE = "default";
